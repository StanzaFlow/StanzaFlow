"""LangGraph adapter for StanzaFlow workflows."""

from pathlib import Path
from typing import Any
import os

from stanzaflow.core.exceptions import CompileError


class LangGraphEmitter:
    """Emits LangGraph code from StanzaFlow IR."""

    def __init__(self) -> None:
        """Initialize the emitter."""
        pass

    def emit(self, ir: dict[str, Any], output_path: Path) -> None:
        """Emit LangGraph code from IR to output path.

        Args:
            ir: StanzaFlow IR dictionary
            output_path: Path where to write the generated code (file or directory)
        """
        if ir.get("ir_version") != "0.2":
            raise CompileError(f"Unsupported IR version: {ir.get('ir_version')}")

        workflow = ir.get("workflow", {})
        title = workflow.get("title", "Untitled Workflow")
        agents = workflow.get("agents", [])

        # Generate the LangGraph code
        code_lines = self._generate_code(ir)

        # Determine the actual file path
        if output_path.suffix == ".py":
            # If it's a .py file, use it directly
            file_path = output_path
        else:
            # If it's a directory, generate filename
            filename = f"{self._sanitize_name(title, 'workflow')}.py"
            file_path = output_path / filename

        # Ensure parent directory exists
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, "w", encoding="utf-8") as f:
            f.write("\n".join(code_lines))

    def _generate_code(self, ir: dict[str, Any]) -> list[str]:
        """Generate LangGraph code from IR."""
        workflow = ir.get("workflow", {})
        title = workflow.get("title", "Untitled Workflow")
        agents = workflow.get("agents", [])
        secrets = workflow.get("secrets", [])
        
        code_lines = [
            "# Generated by StanzaFlow",
            "# MIT License",
            "",
            "import os",
            "from typing import Dict, Any",
            "from langgraph.graph import StateGraph, END",
            "",
        ]
        
        # Add secret environment variables
        if secrets:
            code_lines.extend([
                "# Environment variables (secrets)",
            ])
            for secret in secrets:
                env_var = secret.get("env_var")
                if env_var:
                    code_lines.append(f'{env_var} = os.environ["{env_var}"]')
            code_lines.append("")
        
        # State definition
        code_lines.extend([
            "# State definition", 
            "class WorkflowState(Dict[str, Any]):",
            '    """State for the workflow."""',
            "    artifacts: Dict[str, str] = {}",
            "",
        ])

        # Generate agent functions
        for i, agent in enumerate(agents):
            agent_name = agent.get("name", f"Agent{i+1}")
            steps = agent.get("steps", [])

            # Generate function for this agent
            function_name = self._sanitize_name(agent_name, "agent")
            code_lines.extend(
                [
                    f"def {function_name}_agent(state: WorkflowState) -> WorkflowState:",
                    f'    """Execute {agent_name} agent steps."""',
                    f'    print(f"Executing {agent_name} agent")',
                    "    ",
                ]
            )

            # Generate steps for this agent
            for j, step in enumerate(steps):
                step_name = step.get("name", f"Step{j+1}")
                attributes = step.get("attributes", {})

                code_lines.extend(
                    [
                        f"    # Step: {step_name}",
                        f'    print(f"  - {step_name}")',
                    ]
                )

                # Handle step attributes (basic implementation)
                if "artifact" in attributes:
                    artifact_name = attributes["artifact"]
                    code_lines.append(
                        f'    state["artifacts"]["{artifact_name}"] = "Generated content for {step_name}"'
                    )

                # Implement retry logic
                if "retry" in attributes:
                    retry_count = attributes["retry"]
                    code_lines.extend([
                        f"    # Retry logic for {step_name}",
                        f"    max_retries = {retry_count}",
                        "    last_exception = None",
                        "    for attempt in range(max_retries + 1):",
                        "        try:",
                        f"            # Execute {step_name} logic here",
                        "            break  # Success, exit retry loop",
                        "        except Exception as e:",
                        "            last_exception = e",
                        "            if attempt == max_retries:",
                        f'                raise RuntimeError(f"Step {step_name} failed after {{max_retries}} retries") from last_exception',
                        f'            print(f"Retry {{attempt + 1}}/{{max_retries}} for {step_name}: {{e}}")',
                        "            continue",
                    ])

                # Implement timeout handling
                if "timeout" in attributes:
                    timeout_seconds = attributes["timeout"]
                    code_lines.extend([
                        f"    # Timeout handling for {step_name}",
                        "    import signal",
                        "    import threading",
                        "    import time",
                        "    ",
                        "    # Cross-platform timeout implementation",
                        "    if hasattr(signal, 'SIGALRM'):",
                        "        # Unix-style timeout using signal.alarm",
                        "        def timeout_handler(signum, frame):",
                        f'            raise TimeoutError(f"Step {step_name} timed out after {timeout_seconds} seconds")',
                        "        signal.signal(signal.SIGALRM, timeout_handler)",
                        f"        signal.alarm({timeout_seconds})",
                        "        try:",
                        f"            # Execute {step_name} with timeout protection",
                        "            pass  # Replace with actual step logic",
                        "        finally:",
                        "            signal.alarm(0)  # Cancel timeout",
                        "    else:",
                        "        # Windows-compatible timeout using threading.Timer",
                        "        timeout_event = threading.Event()",
                        "        def timeout_callback():",
                        f'            if not timeout_event.is_set(): raise TimeoutError(f"Step {step_name} timed out after {timeout_seconds} seconds")',
                        f"        timer = threading.Timer({timeout_seconds}, timeout_callback)",
                        "        timer.start()",
                        "        try:",
                        f"            # Execute {step_name} with timeout protection",
                        "            pass  # Replace with actual step logic",
                        "            timeout_event.set()  # Signal completion",
                        "        finally:",
                        "            timer.cancel()  # Cancel timeout timer",
                    ])

                # TODO hints for unimplemented attributes
                unsupported = [
                    key
                    for key in attributes.keys()
                    if key not in {"artifact", "retry", "timeout"}
                ]

                if unsupported:
                    code_lines.append(
                        f"    # TODO[escape]: Unsupported attributes â†’ {', '.join(unsupported)}"
                    )

                code_lines.append("    ")

            code_lines.extend(
                [
                    "    return state",
                    "",
                ]
            )

        # Generate the main workflow graph
        code_lines.extend(
            [
                "def create_workflow() -> StateGraph:",
                f'    """Create the {title} workflow graph."""',
                "    graph = StateGraph(WorkflowState)",
                "    ",
            ]
        )

        # Add agent nodes
        for i, agent in enumerate(agents):
            agent_name = agent.get("name", f"Agent{i+1}")
            function_name = self._sanitize_name(agent_name, "agent")
            code_lines.append(
                f'    graph.add_node("{function_name}", {function_name}_agent)'
            )

        code_lines.append("    ")

        # Add edges (sequential for now)
        if len(agents) > 1:
            code_lines.append("    # Sequential workflow")
            for i in range(len(agents) - 1):
                current_agent = self._sanitize_name(
                    agents[i].get("name", f"Agent{i+1}"), "agent"
                )
                next_agent = self._sanitize_name(
                    agents[i + 1].get("name", f"Agent{i+2}"), "agent"
                )
                code_lines.append(
                    f'    graph.add_edge("{current_agent}", "{next_agent}")'
                )

            # Set entry point and end
            first_agent = self._sanitize_name(agents[0].get("name", "Agent1"), "agent")
            last_agent = self._sanitize_name(
                agents[-1].get("name", f"Agent{len(agents)}"), "agent"
            )
            code_lines.extend(
                [
                    "    ",
                    f'    graph.set_entry_point("{first_agent}")',
                    f'    graph.add_edge("{last_agent}", END)',
                ]
            )
        elif len(agents) == 1:
            agent_name = self._sanitize_name(agents[0].get("name", "Agent1"), "agent")
            code_lines.extend(
                [
                    f'    graph.set_entry_point("{agent_name}")',
                    f'    graph.add_edge("{agent_name}", END)',
                ]
            )
        else:
            raise CompileError("No agents found in workflow")

        code_lines.extend(
            [
                "    ",
                "    return graph.compile()",
                "",
                "",
                'if __name__ == "__main__":',
                "    workflow = create_workflow()",
                '    initial_state = {"data": {}, "artifacts": {}}',
                "    result = workflow.invoke(initial_state)",
                f'    print(f"Workflow {title} completed: {{result}}")',
            ]
        )

        return code_lines

    def _sanitize_name(self, name: str, prefix: str = "item") -> str:
        """Sanitize a name for use as a Python identifier.

        Args:
            name: The name to sanitize
            prefix: Prefix to use if name doesn't start with a letter (default: "item")
        """
        import re
        import hashlib

        # Check if original name starts with a valid identifier character
        original_starts_valid = name and (name[0].isalpha() or name[0] == "_")

        # Replace non-alphanumeric characters with underscores
        sanitized = re.sub(r"[^a-zA-Z0-9_]", "_", name)

        # Add prefix if original name didn't start with valid character
        if not original_starts_valid:
            # Remove leading underscores that came from replacement and add prefix
            sanitized = sanitized.lstrip("_")
            sanitized = f"{prefix}_{sanitized}" if sanitized else prefix

        # Handle long names to keep paths under 128 chars (Windows compatibility)
        max_length = 40  # Conservative limit to account for file extensions and paths
        if len(sanitized) > max_length:
            # Keep first part and add hash suffix
            hash_suffix = hashlib.sha1(name.encode()).hexdigest()[:8]
            truncated = sanitized[:max_length - 9]  # Leave room for underscore and hash
            sanitized = f"{truncated}_{hash_suffix}"

        return sanitized.lower()


def compile_to_langgraph(ir: dict[str, Any], output_path: Path) -> None:
    """Compile StanzaFlow IR to LangGraph code.

    Args:
        ir: StanzaFlow IR dictionary
        output_path: Path where to write the generated code
    """
    emitter = LangGraphEmitter()
    emitter.emit(ir, output_path)
