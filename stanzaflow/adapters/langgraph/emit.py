"""LangGraph adapter for StanzaFlow workflows."""

from typing import Any, Dict, List
from pathlib import Path
import json

from stanzaflow.core.exceptions import CompileError, UnsupportedPattern


class LangGraphEmitter:
    """Emits LangGraph code from StanzaFlow IR."""
    
    def __init__(self) -> None:
        """Initialize the emitter."""
        pass
    
    def emit(self, ir: Dict[str, Any], output_path: Path) -> None:
        """Emit LangGraph code from IR to output path.
        
        Args:
            ir: StanzaFlow IR dictionary
            output_path: Path where to write the generated code
        """
        if ir.get("ir_version") != "0.2":
            raise CompileError(f"Unsupported IR version: {ir.get('ir_version')}")
        
        workflow = ir.get("workflow", {})
        title = workflow.get("title", "Untitled Workflow")
        agents = workflow.get("agents", [])
        
        # Generate the LangGraph code
        code_lines = []
        
        # MIT header
        code_lines.extend([
            "# MIT License",
            "# Generated by StanzaFlow",
            "",
            '"""Generated LangGraph workflow."""',
            "",
            "from typing import Dict, Any, TypedDict",
            "from langgraph.graph import StateGraph, END",
            "",
            "# Workflow state schema",
            "class WorkflowState(TypedDict):",
            '    """State for the workflow."""',
            "    data: Dict[str, Any]",
            "    artifacts: Dict[str, str]",
            "",
        ])
        
        # Generate agent functions
        for i, agent in enumerate(agents):
            agent_name = agent.get("name", f"Agent{i+1}")
            steps = agent.get("steps", [])
            
            # Generate function for this agent
            function_name = self._sanitize_name(agent_name)
            code_lines.extend([
                f"def {function_name}_agent(state: WorkflowState) -> WorkflowState:",
                f'    """Execute {agent_name} agent steps."""',
                f'    print(f"Executing {agent_name} agent")',
                "    ",
            ])
            
            # Generate steps for this agent
            for j, step in enumerate(steps):
                step_name = step.get("name", f"Step{j+1}")
                attributes = step.get("attributes", {})
                
                code_lines.extend([
                    f'    # Step: {step_name}',
                    f'    print(f"  - {step_name}")',
                ])
                
                # Handle step attributes (basic implementation)
                if "artifact" in attributes:
                    artifact_name = attributes["artifact"]
                    code_lines.append(f'    state["artifacts"]["{artifact_name}"] = "Generated content for {step_name}"')
                
                # TODO: Handle other attributes (retry, timeout, etc.)
                if "retry" in attributes or "timeout" in attributes or "on_error" in attributes:
                    code_lines.append("    # TODO: Handle retry/timeout/error attributes")
                
                code_lines.append("    ")
            
            code_lines.extend([
                "    return state",
                "",
            ])
        
        # Generate the main workflow graph
        code_lines.extend([
            "def create_workflow() -> StateGraph:",
            f'    """Create the {title} workflow graph."""',
            "    graph = StateGraph(WorkflowState)",
            "    ",
        ])
        
        # Add agent nodes
        for i, agent in enumerate(agents):
            agent_name = agent.get("name", f"Agent{i+1}")
            function_name = self._sanitize_name(agent_name)
            code_lines.append(f'    graph.add_node("{function_name}", {function_name}_agent)')
        
        code_lines.append("    ")
        
        # Add edges (sequential for now)
        if len(agents) > 1:
            code_lines.append("    # Sequential workflow")
            for i in range(len(agents) - 1):
                current_agent = self._sanitize_name(agents[i].get("name", f"Agent{i+1}"))
                next_agent = self._sanitize_name(agents[i+1].get("name", f"Agent{i+2}"))
                code_lines.append(f'    graph.add_edge("{current_agent}", "{next_agent}")')
            
            # Set entry point and end
            first_agent = self._sanitize_name(agents[0].get("name", "Agent1"))
            last_agent = self._sanitize_name(agents[-1].get("name", f"Agent{len(agents)}"))
            code_lines.extend([
                "    ",
                f'    graph.set_entry_point("{first_agent}")',
                f'    graph.add_edge("{last_agent}", END)',
            ])
        elif len(agents) == 1:
            agent_name = self._sanitize_name(agents[0].get("name", "Agent1"))
            code_lines.extend([
                f'    graph.set_entry_point("{agent_name}")',
                f'    graph.add_edge("{agent_name}", END)',
            ])
        else:
            raise CompileError("No agents found in workflow")
        
        code_lines.extend([
            "    ",
            "    return graph.compile()",
            "",
            "",
            'if __name__ == "__main__":',
            "    workflow = create_workflow()",
            '    initial_state = {"data": {}, "artifacts": {}}',
            "    result = workflow.invoke(initial_state)",
            f'    print(f"Workflow {title} completed: {{result}}")',
        ])
        
        # Write the generated code
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w") as f:
            f.write("\n".join(code_lines))
    
    def _sanitize_name(self, name: str) -> str:
        """Sanitize a name for use as a Python identifier."""
        # Remove non-alphanumeric characters and replace with underscore
        import re
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure it starts with a letter or underscore (only prepend _ if needed)
        if sanitized and not sanitized[0].isalpha() and sanitized[0] != '_':
            sanitized = f"_{sanitized}"
        return sanitized.lower()


def compile_to_langgraph(ir: Dict[str, Any], output_path: Path) -> None:
    """Compile StanzaFlow IR to LangGraph code.
    
    Args:
        ir: StanzaFlow IR dictionary
        output_path: Path where to write the generated code
    """
    emitter = LangGraphEmitter()
    emitter.emit(ir, output_path) 